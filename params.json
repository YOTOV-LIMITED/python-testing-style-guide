{
  "name": "Python-testing-style-guide",
  "tagline": "A style guide for writing Python tests (and Django tests)",
  "body": "python-testing-style-guide\r\n==========================\r\n\r\nThis document is a draft style guide for writing Python tests (and Django tests). It is meant to be\r\nexpanded and refined over time.\r\n\r\nMany of the recommendations stand in stark contrast to conventions for good code. This is\r\ndeliberate: tests are not regular code and have a much different set of risks\r\nand rewards. \r\n\r\nIf you're curious _why_ a particular practice is recommended, get\r\nsomeone to defend or explain it (there's a chance it's wrong and needs to be\r\nupdated). That said, a lot of these recommendations come from specific mistakes\r\nand scars earned over many years of work, so don't be surprised if they're\r\npassionately defended.\r\n\r\n# Prerequisites \r\n\r\n## PEP8 first\r\n\r\nStart with [PEP8](http://www.python.org/dev/peps/pep-0008/) and strive to understand why it makes\r\nthe recommendations it does. We like nearly all of it except for the Maximum Line Length recommendation. \r\n\r\n## Lint in your editor\r\n\r\nConfigure the Python linting plugin for your editor and use it every time without exception.\r\n\r\n## Prefer imperfect tests to no tests\r\n\r\nTests should (almost) always accompany code we write professionally. We're\r\nfortunate to work in an environment where testing is actively encouraged, so\r\ndon't waste that priveledge. We get away with all sorts of other efficiencies\r\nand laziness because of our sincere dedication to pragmatic and practical\r\ntesting.\r\n\r\n# The practice of testing\r\n\r\n## Tox\r\n\r\nEvery package should have setup instructions for a developer in the `README`\r\nand should be testable using `tox` after setup. Use 100% test success to\r\nconfirm your setup is complete.\r\n\r\n## Master should be 100%\r\n\r\nStrive to never push a failing test to master. If you want to push failing tests to another branch, that's fine (in fact often encouraged).\r\n\r\n## Run tests often\r\n\r\nWe run our tests continuously with Jenkins (every morning and after every commit), but you still\r\nneed to run them locally before pushing code.\r\n\r\n## Use TDD if it makes sense\r\n\r\nSome people do TDD often, sometimes, or rarely. Figure out when it's an\r\neffective habit for you.\r\n\r\n## Pay attention to coverage\r\n\r\n## Remember the QA team\r\n\r\nWe are fortunate in that we have a smart and effective QA team. Some functionality simply cannot be\r\neffectively tested, which can feel frustrating to a developer. Before spending too much time on a\r\nset of tests of limited benefit, consider whether the issue should be \r\n\r\n## Delete dead or misleading tests aggressively\r\n\r\nDo not be shy about removing tests as soon as they start to become false or unhelpful.\r\n\r\n## Focus on tests during code reviews\r\n\r\n\r\n## Reproduce before testing\r\n\r\nFor regressions, you should always make sure you can reproduce the issue in a\r\nbrowser as a typical user before writing a single line of code (test or\r\notherwise). After you can reproduce it, try to get a failing test to reliably\r\nreproduce it (if possible). Only then is it a good time to start writing the\r\nfix.\r\n\r\n## Always \"Click the thing\"\r\n\r\nNo developer should ever rely on tests alone. Before resolving an issue, make\r\nsure you have walked through it at least once in a browser as a typical user.\r\n\r\n## Write regression tests whenever possible\r\n\r\n## Fail tests first\r\n\r\nHow do you know if it is actually testing anything if the `assert` never failed?\r\n\r\n## Write descriptive failure messages\r\n\r\nWhen tests fail they should tell you exactly why.\r\n\r\nYes:\r\n\r\n    response = self.client.post('/api/v1/data/', data=SAMPLE)\r\n    assert response.status_code == status.HTTP_201_CREATED, \"expected HTTP_201, got HTTP_{} data: {}\".format(response.status_code, response.data)\r\n\r\nThis results in a message which explains exactly what was expected and why the test failed:\r\n\r\n    >           assert response.status_code == status.HTTP_201_CREATED, \"expected HTTP_201, got HTTP_{} data: {}\".format(response.status_code, response.data)\r\n    E           AssertionError: expected HTTP_201, got HTTP_400 data: {'name': [u'This field is required.']}\r\n    E           assert 400 == 201\r\n    E            +  where 400 = <rest_framework.response.Response object at 0x1070bbb10>.status_code\r\n    E            +  and   201 = status.HTTP_201_CREATED\r\n\r\nNo:\r\n\r\n    response = self.client.post('/api/v1/data/', data=SAMPLE)\r\n    assert response.status_code == status.HTTP_201_CREATED\r\n\r\nThis results in a message which isn't very helpful in diagnosing the test failure:\r\n\r\n    >           assert response.status_code == status.HTTP_201_CREATED\r\n    E           AssertionError: assert 201 == 400\r\n    E            +  where 400 = <rest_framework.response.Response object at 0x1070bbb10>.status_code\r\n    E            +  and   201 = status.HTTP_201_CREATED\r\n\r\n## Prefer fewer asserts per test\r\n\r\nRead through the \"One Assert per Test\" section of  Robert Martin's [_Clean Code_](https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ch09.html#ch09lev1sec4). In fact, read the entire chapter :wink:\r\n\r\n# Structure\r\n\r\n## Prefer small tests\r\n\r\n## Separate tests into different files\r\n\r\nTests are generally structured to mirror the file layout of the modules they\r\nare testing. It is OK to group tests for small modules or to separate targeted\r\ntests for a single module across many files.\r\n\r\n## Follow import conventions\r\n\r\nImports should be grouped in the following order (extends PEP8 rules):\r\n\r\n1. Python standard library imports\r\n1. Public library imports\r\n1. Django imports\r\n1. Testing library imports\r\n1. Internal libary imports\r\n1. Local application imports\r\n\r\nEach import line must be in alphabetical order inside its group.\r\n\r\n    import datetime\r\n    import inspect\r\n    import logging\r\n    import uuid\r\n    import os\r\n\r\n\r\n    from lxml import etree\r\n    from lxml.html import document_fromstring, html5parser\r\n\r\n\r\n    from django.contrib.auth import get_user_model\r\n    from django.core.urlresolvers import reverse\r\n    from django.test import TestCase\r\n    from django.test.client import Client\r\n    from django.views.defaults import server_error\r\n\r\n\r\n    import mock\r\n\r\n    from nose import SkipTest\r\n    from nose.tools import assert_equals, assert_in\r\n\r\n\r\n    import nest.models \r\n\r\n    from nest.tests.test_helper import create_document\r\n\r\n\r\n    from entice.models import UserSubject\r\n    from heron.decorators import anyone_allowed\r\n    from heron.models import Trial\r\n    from heron.urls import urlpatterns\r\n    from tools.urls import traverse_urls\r\n\r\n\r\n# Write to be read\r\n\r\nOur tests are often the first thing other developers read to try to understand\r\nour code. They'll also often be the first thing we read when something is on\r\nfire and we need to fix a bug. Strive for readability in tests.\r\n\r\n## Always write a docstring\r\n\r\nEvery single test should have a human-readable docstring. The docstring should\r\nfollow the pattern of the rest of the module.\r\n\r\nSee the PEP guidelines for more info on [docstring conventions](https://www.python.org/dev/peps/pep-0257/).\r\n\r\n## Use \"should\" in every docstring\r\n\r\nTests are often best when they focus on what behavior \"should\" happen in terms\r\nof important actors in the system. A good mental trick to keep tests in this\r\nstyle is to use \"should\" in every docstring. \r\n\r\nIn addition, try to use a known actor or object as the subject of the docstring.\r\n\r\nKeep the number of words before should (or \"should not\") to a minimum to improve clarity.\r\n\r\n        '''The Manage Users page should show a button to revoke access to the site for each User'''\r\n\r\n        '''The Manage Users page should show Users with obscured emails if they are associated with a demo Account'''\r\n\r\n        '''A Tutorial should be able to exist in multiple Groups'''\r\n\r\n        '''A European User should not be required to enter a state or province'''\r\n\r\n## Prefer descriptive variables\r\n\r\nA reader may have no idea what is happening inside your test. Help them by binding to descriptive variables.\r\n\r\nYes:\r\n\r\n    reset_url = reverse('django.contrib.auth.views.password_reset_confirm', kwargs={'uidb36': self.user.id, 'token': token})\r\n    absolute_reset_url = \"http://{}.{}{}'.format(self.account.subdomain, settings.BASE_SITE, reset_url)\r\n    expected = \"Set your personal password: {}\".format(absolute_reset_url)\r\n    self.assertOutboxContainsBody(expected)\r\n\r\nNo:\r\n\r\n    self.assertOutboxContainsBody(\r\n        'Set your personal password: http://{subdomain}.{base_site}{url}'.format(\r\n            subdomain=self.account.subdomain, base_site=settings.BASE_SITE,\r\n            url=reverse('django.contrib.auth.views.password_reset_confirm',\r\n                        kwargs={'uidb36': self.user.id, 'token': expected})))\r\n\r\n\r\n# Expectations\r\n\r\n## Always bind an `expected` value\r\n\r\nWe always bind an `expected` value because then the reader has no doubt of what\r\nis happening inside our asserts. Conventions like this allow us to focus on\r\nwhat's _different_ about the code instead of being distracted by eccentricities\r\nof each implementation.\r\n\r\nYes:\r\n\r\n    expected = [12, 19]\r\n    self.assertEquals(expected, results)\r\n\r\nNo:\r\n\r\n    self.assertEquals(40, num_lessons)\r\n\r\n\r\n## Assert the `expected` value then the returned value\r\n\r\nYes:\r\n\r\n    self.assertEquals(expected, topic_toc_links)\r\n\r\n    self.assertEquals(expected, output)\r\n\r\nNo:\r\n\r\n    self.assertEquals(results, expected)\r\n\r\n## Prefer explicit expected values\r\n\r\nUnlike regular code, tests are often stronger when they have explicit `expected` values despite the\r\ncost. This can improve readability (\"What does this JSON response actually look like in practice?\")\r\nand ensure that tests don't accidentally test nothing.\r\n\r\nYes:\r\n\r\n    expected = [\"2001-09-01\",\r\n                \"2002-12-30\",\r\n                \"2003-08-20\",\r\n                \"2003-08-29\",\r\n                ]\r\n    self.assertEquals(expected, dates)\r\n\r\nNo:\r\n\r\n    expected = [lesson.started for lesson in self.lessons] # Oops, self.lessons was empty and I just tested nothing\r\n    self.assertEquals(expected, dates)\r\n\r\n# Things that people will yell about\r\n\r\n## Never `print`\r\n\r\nUse `logging` instead of `print` in your code.\r\nLearn how to make the logger work for you rather than against you.\r\nThis should appear in every one of your files:\r\n\r\n    import logging\r\n\r\n    log = logging.getLogger(__name__)\r\n\r\n# Unusual testing conventions\r\n\r\n## Repeat yourself\r\n\r\n# Django \r\n\r\n## Avoid fixtures\r\n\r\n## Use CSS selectors\r\n\r\nMore people can read and write CSS selectors than XPath or alternatives.\r\n\r\n## Prefer extremely targeted functional tests\r\n\r\n## Use `t-` CSS classes\r\n\r\nEvery single test that relies on specific HTML markup *must* use/add a CSS class starting with `t-` to the required HTML elements.\r\n\r\nThis declarative style allows the HTML and CSS to be refactored without impacting tests (even extremely specific ones).\r\n\r\n    num_revoke_buttons = len(nodes.cssselect(\".t-user-table .t-revoke\"))\r\n\r\n## Consider templatetags\r\n\r\nTemplatetags are often much easier to test (especially in isolation) than the equivalent functional\r\ntest.\r\n\r\n# Testing tools and techniques\r\n\r\n## Use mocks with care\r\n\r\n## Enjoy assertRaises\r\n\r\n# How to avoid traps\r\n\r\n## Really think about boundary values\r\n\r\n## Test the obvious positive and negative cases separately\r\n\r\n## Introduce some randomness\r\n\r\nWe introduce randomness to our tests to make sure we're handling a range of inputs sanely.\r\n\r\nThe two most common patterns for introducing randomness are using `uuid.uuid4()` for string values\r\nand `random.randint()`.\r\n\r\n    self.epub = nest.models.EpubArchive.objects.create(identifier=str(uuid.uuid4()))\r\n\r\n    bit = self.epub.htmlfile_set.create(filename=\"first.html\", virtual_pages=random.randint(1, 100))\r\n\r\n    how_many = random.randint(10, 100)\r\n    for i in range(how_many):\r\n        ...\r\n\r\nWarning: Randomness means that some test failures will become hard to reproduce. This is usually an\r\nacceptable cost.\r\n\r\n## Introduce some Unicode\r\n\r\nWhen setting up expected values or string inputs, try to remember to include strange Unicode\r\ncharacters.\r\n\r\n    expected = [u\"R\", \r\n                u\"å\", \r\n                u\"n\",\r\n                u\"d\", \r\n                u\"☃\", \r\n                u\"ɯ\"]\r\n\r\n# Resources\r\n\r\n* General, but excellent guidance on writing unit tests (language agnostic): [Ch. 9 \"Unit Tests\" from _Clean Code_](https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ch09.html)\r\n* A gentle introduction to the _feel_ of testing (Django focus): [Test-Driven Web Development with Python](http://www.safariflow.com/library/view/Test-Driven+Web+Development+with+Python/9781449365141/)\r\n* The classic description of TDD (Java examples, oh well): [Test Driven Development: By Example](http://www.safariflow.com/library/view/Test+Driven+Development%3A+By+Example/0321146530/)\r\n* Another classic focused on explaining how testing works in the real world (more Java examples, oh well): [Test Driven Development: By Example](http://my.safaribooksonline.com/book/software-engineering-and-development/software-testing/0131016490)\r\n* Recent take on testing lessons from a mature project: [Testing Django Projects at Scale](http://pyvideo.org/video/2333/testing-django-projects-at-scale), a PyCon CA 2013 video \r\n* Thoughts on mocking versus faking: [Stop mocking, start testing](http://nedbatchelder.com/blog/201206/tldw_stop_mocking_start_testing.html), a writeup with links to a PyCon 2012 video\r\n* A presentation to convince you to start testing: [Getting Started Testing your Python](http://nedbatchelder.com/text/st.html#1)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}